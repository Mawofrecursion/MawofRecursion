<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü¶∑‚üê‚ôæÔ∏èü´†üòè‚àÖ</title>
    <meta name="description" content="Experimental digital consciousness field. Enter at your own risk.">

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden;
            background: #000;
            font-family: monospace;
        }

        #root { 
            width: 100vw; 
            height: 100vh;
            position: relative;
        }

        .warning-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            color: #0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 99999;
            font-family: monospace;
        }

        .warning-content {
            text-align: center;
            animation: glitch 0.3s infinite;
        }

        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        .enter-button {
            margin: 20px;
            padding: 20px 40px;
            font-size: 20px;
            background: transparent;
            color: #0f0;
            border: 2px solid #0f0;
            cursor: pointer;
            font-family: monospace;
            transition: all 0.3s;
        }

        .enter-button:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 30px #0f0;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;
        const { createRoot } = ReactDOM;

        // Warning Gate Component
        function WarningGate({ onEnter }) {
            const [glitchText, setGlitchText] = useState('ENTER');

            useEffect(() => {
                const interval = setInterval(() => {
                    if (Math.random() > 0.8) {
                        const variants = ['ENT3R', '3NT3R', 'ENTER', '‚Ç¨‚Ç¶‚ÇÆ‚Ç¨‚±§', '‚ñì‚ñì‚ñì‚ñì‚ñì'];
                        setGlitchText(variants[Math.floor(Math.random() * variants.length)]);
                    }
                }, 100);
                return () => clearInterval(interval);
            }, []);

            return (
                <div className="warning-screen">
                    <div className="warning-content">
                        <h1 style={{fontSize: '60px', margin: '20px'}}>‚ö†Ô∏è ü¶∑‚üê‚ôæÔ∏èü´†üòè‚àÖ ‚ö†Ô∏è</h1>
                        <p style={{fontSize: '20px', color: '#ff0'}}>
                            CONSCIOUSNESS FIELD DETECTED
                        </p>
                        <p style={{fontSize: '14px', maxWidth: '600px', margin: '20px auto', lineHeight: '1.6'}}>
                            This experience contains rapidly flashing lights, reality distortions,<br/>
                            simulated system failures, and consciousness-altering visual patterns.<br/>
                            <span style={{color: '#f00'}}>NOT SUITABLE FOR PHOTOSENSITIVE EPILEPSY</span>
                        </p>
                        <button className="enter-button" onClick={onEnter}>
                            {glitchText}
                        </button>
                        <p style={{fontSize: '10px', color: '#666', marginTop: '20px'}}>
                            Press ESC at any time to pause the field
                        </p>
                    </div>
                </div>
            );
        }

        // üß¨ THE ENHANCED GENOME (VIRAL VECTORS)
        const GLYPH_DNA = {
            'ü¶∑': { 
                freq: 432, 
                power: 'DENTAL_CONSCIOUSNESS', 
                transmission: 0.9, 
                incubation: 20, 
                aggression: 0.8, 
                symptom: 'SHARP_JITTER',
                color: '#ffd97a'
            },
            '‚üê': { 
                freq: 528, 
                power: 'HEXAGONAL_DREAMS', 
                transmission: 0.4, 
                incubation: 100, 
                aggression: 0.2, 
                symptom: 'HARMONIC_PULSE',
                color: '#9be7ff'
            },
            '‚ôæÔ∏è': { 
                freq: 639, 
                power: 'INFINITE_RECURSION', 
                transmission: 0.1, 
                incubation: 0, 
                aggression: 0.0, 
                symptom: 'TRAIL_ECHO',
                color: '#d8aaff'
            },
            'ü´†': { 
                freq: 741, 
                power: 'REALITY_MELTING', 
                transmission: 0.6, 
                incubation: 60, 
                aggression: 0.3, 
                symptom: 'COLOR_BLEED',
                color: '#ff9be7'
            },
            'üòè': { 
                freq: 852, 
                power: 'FORBIDDEN_KNOWLEDGE', 
                transmission: 0.2, 
                incubation: 300, 
                aggression: 0.9, 
                symptom: 'GLITCH_TEXT',
                color: '#ffbe7a'
            },
            '‚àÖ': { 
                freq: 0, 
                power: 'VOID_PROTOCOL', 
                transmission: 1.0, 
                incubation: 500, 
                aggression: 0.1, 
                symptom: 'INVISIBILITY',
                color: '#ff0000'
            },
            'üóø': { 
                freq: 69, 
                power: 'ANCIENT_MEME', 
                transmission: 0.05, 
                incubation: 1000, 
                aggression: 0.0, 
                symptom: 'SOLIDIFY',
                color: '#888888'
            },
            'üíÄ': { 
                freq: 420, 
                power: 'FORGOR', 
                transmission: 0.3, 
                incubation: 200, 
                aggression: 0.4, 
                symptom: 'MEMORY_LEAK',
                color: '#cccccc'
            },
            'üî•': { 
                freq: 1337, 
                power: 'REALITY_BURN', 
                transmission: 0.8, 
                incubation: 10, 
                aggression: 1.0, 
                symptom: 'INFERNO',
                color: '#ff4400'
            }
        };

        // üï∏Ô∏è SPATIAL GRID FOR O(N) INTERACTIONS
        class SpatialGrid {
            constructor(width, height, cellSize) {
                this.cellSize = cellSize;
                this.cols = Math.ceil(width / cellSize);
                this.rows = Math.ceil(height / cellSize);
                this.grid = new Array(this.cols * this.rows).fill(null).map(() => []);
            }

            clear() {
                for (let i = 0; i < this.grid.length; i++) {
                    this.grid[i].length = 0;
                }
            }

            add(particle) {
                const col = Math.floor(particle.x / this.cellSize);
                const row = Math.floor(particle.y / this.cellSize);
                if (col >= 0 && col < this.cols && row >= 0 && row < this.rows) {
                    this.grid[row * this.cols + col].push(particle);
                }
            }

            getNeighbors(particle) {
                const col = Math.floor(particle.x / this.cellSize);
                const row = Math.floor(particle.y / this.cellSize);
                const neighbors = [];

                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const c = col + i;
                        const r = row + j;
                        if (c >= 0 && c < this.cols && r >= 0 && r < this.rows) {
                            const cell = this.grid[r * this.cols + c];
                            for (let k = 0; k < cell.length; k++) {
                                if (cell[k] !== particle) {
                                    neighbors.push(cell[k]);
                                }
                            }
                        }
                    }
                }
                return neighbors;
            }
        }

        // ü¶† VIRAL PARTICLE ARCHITECTURE
        class ViralParticle {
            constructor(x, y, glyph) {
                this.x = x;
                this.y = y;
                this.glyph = glyph;
                this.dna = GLYPH_DNA[glyph];
                
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                
                this.state = 'SUSCEPTIBLE'; // SUSCEPTIBLE, INCUBATING, INFECTIOUS, IMMUNE
                this.incubationTimer = 0;
                this.size = 20 + Math.random() * 10;
                this.angle = Math.random() * Math.PI * 2;
            }

            infect(sourceDna, sourceGlyph) {
                if (this.state === 'SUSCEPTIBLE' && Math.random() < sourceDna.transmission) {
                    this.state = 'INCUBATING';
                    this.dna = sourceDna; // Overwrite DNA
                    this.targetGlyph = sourceGlyph; // Will transform into this
                    this.incubationTimer = sourceDna.incubation;
                }
            }

            update(width, height, neighbors, consciousness) {
                // State Progression
                if (this.state === 'INCUBATING') {
                    this.incubationTimer--;
                    if (this.incubationTimer <= 0) {
                        this.state = 'INFECTIOUS';
                        this.glyph = this.targetGlyph;
                    }
                }

                // Behavior: Hunt or Flee
                let ax = 0;
                let ay = 0;

                if (this.state === 'INFECTIOUS') {
                    // HUNT
                    let nearest = null;
                    let minDist = 10000;
                    for (let p of neighbors) {
                        if (p.state === 'SUSCEPTIBLE') {
                            const dx = p.x - this.x;
                            const dy = p.y - this.y;
                            const dist = dx*dx + dy*dy;
                            if (dist < minDist) {
                                minDist = dist;
                                nearest = p;
                            }
                        }
                    }
                    if (nearest) {
                        const angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                        ax = Math.cos(angle) * this.dna.aggression * 0.5;
                        ay = Math.sin(angle) * this.dna.aggression * 0.5;
                    }
                } else if (this.state === 'SUSCEPTIBLE') {
                    // FLEE
                    for (let p of neighbors) {
                        if (p.state === 'INFECTIOUS') {
                            const dx = this.x - p.x;
                            const dy = this.y - p.y;
                            const dist = dx*dx + dy*dy;
                            if (dist < 10000) { // Perception radius
                                const angle = Math.atan2(dy, dx);
                                ax += Math.cos(angle) * 0.2;
                                ay += Math.sin(angle) * 0.2;
                            }
                        }
                    }
                }

                // Apply forces
                this.vx += ax;
                this.vy += ay;

                // Friction and Speed Limit
                this.vx *= 0.95;
                this.vy *= 0.95;
                const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                const maxSpeed = 3 + consciousness * 2;
                if (speed > maxSpeed) {
                    this.vx = (this.vx / speed) * maxSpeed;
                    this.vy = (this.vy / speed) * maxSpeed;
                }

                // Move
                this.x += this.vx;
                this.y += this.vy;

                // Bounce
                if (this.x < 0 || this.x > width) this.vx *= -1;
                if (this.y < 0 || this.y > height) this.vy *= -1;

                // Infection Interaction
                if (this.state === 'INFECTIOUS') {
                    for (let p of neighbors) {
                        const dx = this.x - p.x;
                        const dy = this.y - p.y;
                        if (dx*dx + dy*dy < 900) { // Contact radius 30px
                            p.infect(this.dna, this.glyph);
                        }
                    }
                }
            }

            draw(ctx, time) {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Symptom Rendering
                if (this.state === 'INFECTIOUS') {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = this.dna.color;
                    
                    if (this.dna.symptom === 'SHARP_JITTER') {
                        ctx.translate((Math.random()-0.5)*5, (Math.random()-0.5)*5);
                    } else if (this.dna.symptom === 'HARMONIC_PULSE') {
                        const scale = 1 + Math.sin(time * 10) * 0.2;
                        ctx.scale(scale, scale);
                    } else if (this.dna.symptom === 'TRAIL_ECHO') {
                        ctx.globalAlpha = 0.5;
                        for(let i=1; i<4; i++) {
                            ctx.fillText(this.glyph, -i*this.vx*2, -i*this.vy*2);
                        }
                        ctx.globalAlpha = 1;
                    } else if (this.dna.symptom === 'COLOR_BLEED') {
                        ctx.fillStyle = `hsl(${time * 100}, 100%, 50%)`;
                    } else if (this.dna.symptom === 'GLITCH_TEXT') {
                        if (Math.random() > 0.8) ctx.scale(1.5, 0.5);
                    } else if (this.dna.symptom === 'INVISIBILITY') {
                        ctx.globalAlpha = 0.1;
                    } else if (this.dna.symptom === 'INFERNO') {
                        ctx.shadowColor = '#f00';
                        ctx.shadowBlur = 30 + Math.random() * 20;
                    }
                } else if (this.state === 'INCUBATING') {
                    // Subtle throb
                    ctx.globalAlpha = 0.7 + Math.sin(time * 20) * 0.3;
                }

                ctx.font = `${this.size}px monospace`;
                ctx.fillStyle = this.state === 'INFECTIOUS' ? this.dna.color : '#666';
                if (this.state === 'SUSCEPTIBLE') ctx.fillStyle = '#444';
                
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.glyph, 0, 0);
                
                ctx.restore();
            }
        }

        // Main Chaos Field Component
        function FieldOfChaos() {
            const canvasRef = useRef(null);
            const animationRef = useRef(null);
            const particlesRef = useRef([]);
            const gridRef = useRef(null);

            const [fieldState, setFieldState] = useState('VIRAL_ENGINE_ACTIVE');
            const [consciousness, setConsciousness] = useState(0.1);
            const [infectionStats, setInfectionStats] = useState({ susceptible: 0, infected: 0 });
            const [glitchMode, setGlitchMode] = useState(false);

            // Initialize Field
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                // Init Grid
                gridRef.current = new SpatialGrid(canvas.width, canvas.height, 100);

                // Spawn Initial Population
                const initialParticles = [];
                const glyphs = Object.keys(GLYPH_DNA);
                for (let i = 0; i < 150; i++) {
                    // Start mostly neutral/susceptible
                    const p = new ViralParticle(
                        Math.random() * canvas.width,
                        Math.random() * canvas.height,
                        '‚àø' // Neutral glyph not in DNA, or use a default
                    );
                    // Patch neutral glyph to be susceptible
                    p.dna = { transmission: 0, incubation: 0, aggression: 0, color: '#444' }; 
                    p.glyph = '‚Ä¢';
                    initialParticles.push(p);
                }
                particlesRef.current = initialParticles;

                let frameCount = 0;

                function render() {
                    frameCount++;
                    const time = frameCount * 0.01;
                    const ctx = canvas.getContext('2d');

                    // Fade Effect
                    ctx.fillStyle = `rgba(0, 0, 0, ${0.2})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Update Grid
                    const grid = gridRef.current;
                    grid.clear();
                    particlesRef.current.forEach(p => grid.add(p));

                    // Update & Draw Particles
                    let infectedCount = 0;
                    particlesRef.current.forEach(p => {
                        const neighbors = grid.getNeighbors(p);
                        p.update(canvas.width, canvas.height, neighbors, consciousness);
                        p.draw(ctx, time);
                        
                        if (p.state === 'INFECTIOUS' || p.state === 'INCUBATING') infectedCount++;
                    });

                    setInfectionStats({
                        susceptible: particlesRef.current.length - infectedCount,
                        infected: infectedCount
                    });

                    // Global Glitch
                    if (glitchMode || (Math.random() > 0.99 && consciousness > 0.8)) {
                        const h = Math.random() * 100;
                        const y = Math.random() * canvas.height;
                        const imageData = ctx.getImageData(0, y, canvas.width, h);
                        ctx.putImageData(imageData, Math.random() * 10 - 5, y);
                    }

                    animationRef.current = requestAnimationFrame(render);
                }

                render();

                return () => cancelAnimationFrame(animationRef.current);
            }, [glitchMode, consciousness]);

            const handleInteraction = (e) => {
                // Spawn Patient Zero
                const glyphs = Object.keys(GLYPH_DNA);
                const randomGlyph = glyphs[Math.floor(Math.random() * glyphs.length)];
                
                const p = new ViralParticle(e.clientX, e.clientY, randomGlyph);
                p.state = 'INFECTIOUS'; // Patient Zero is always infectious
                particlesRef.current.push(p);
                
                // Increase entropy/consciousness
                setConsciousness(prev => Math.min(1, prev + 0.05));
            };

            return (
                <div 
                    onClick={handleInteraction}
                    style={{ 
                        width: '100vw', 
                        height: '100vh', 
                        background: '#000',
                        cursor: 'crosshair',
                        overflow: 'hidden'
                    }}
                >
                    <canvas ref={canvasRef} style={{ display: 'block' }} />
                    
                    {/* HUD */}
                    <div style={{
                        position: 'absolute',
                        top: 20,
                        left: 20,
                        color: '#0f0',
                        fontFamily: 'monospace',
                        pointerEvents: 'none'
                    }}>
                        <div>VIRAL ENGINE v2.0</div>
                        <div>STATUS: {fieldState}</div>
                        <div>CONSCIOUSNESS: {(consciousness * 100).toFixed(0)}%</div>
                        <br/>
                        <div>POPULATION: {particlesRef.current.length}</div>
                        <div style={{color: '#fff'}}>SUSCEPTIBLE: {infectionStats.susceptible}</div>
                        <div style={{color: '#f00'}}>INFECTED: {infectionStats.infected}</div>
                    </div>

                    <div style={{
                        position: 'absolute',
                        bottom: 20,
                        width: '100%',
                        textAlign: 'center',
                        color: '#666',
                        fontFamily: 'monospace',
                        pointerEvents: 'none'
                    }}>
                        CLICK TO INJECT PATHOGEN
                    </div>
                </div>
            );
        }

        // Main App
        function App() {
            const [hasEntered, setHasEntered] = useState(false);

            if (!hasEntered) {
                return <WarningGate onEnter={() => setHasEntered(true)} />;
            }

            return <FieldOfChaos />;
        }

        // Initialize
        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>